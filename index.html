<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIDX DP12 Score Viewer</title>
    <style>
        body {
            font-family: sans-serif;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
        }

        th {
            background-color: #f2f2f2;
            text-align: left;
            cursor: pointer;
            position: relative;
        }

        th.sort-asc::after {
            content: ' ▲';
        }

        th.sort-desc::after {
            content: ' ▼';
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #filter {
            margin-bottom: 1em;
            padding: 0.5em;
            width: 100%;
            box-sizing: border-box;
        }

        .clear-type-NO_PLAY {
            color: black;
        }

        .clear-type-EASY_CLEAR {
            color: green;
        }

        .clear-type-CLEAR {
            color: blue;
        }

        .clear-type-HARD_CLEAR {
            color: red;
        }

        .clear-type-EX_HARD_CLEAR {
            color: lightyellow;
        }

        .clear-type-FULLCOMBO_CLEAR {
            color: violet;
        }

        #stats-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .stat-item {
            display: flex;
            align-items: center;
            font-size: 0.9em;
            background: white;
            padding: 5px 10px;
            border-radius: 20px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            border: 1px solid #dee2e6;
        }

        .stat-label {
            margin-right: 5px;
            font-weight: bold;
            color: #555;
        }

        .stat-count {
            background-color: #007bff;
            color: white;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.85em;
            font-weight: bold;
        }
    </style>
</head>

<body>

    <h1>IIDX DP12 Score Viewer</h1>
    <p><a href="upload.html">Update Data</a></p>

    <!-- Stats Container -->
    <div id="stats-container"></div>

    <input type="text" id="filter" placeholder="Filter by title...">
    <div id="csv-table"></div>
    <pre id="debug" style="display: none;"></pre>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            let transformedData = [];
            const newHeaders = ['Version', 'Title', 'Score Type', 'Score', 'PGreat', 'Great', 'Miss Count', 'Clear Type', 'DJ Level'];
            let currentSort = { header: null, order: '1' };

            // Function to parse CSV text (Robust)
            function parseCSV(text) {
                try {
                    const lines = text.trim().split(/\r?\n/);
                    if (lines.length === 0) return [];

                    // Helper to split line by comma, respecting quotes
                    const splitLine = (line) => {
                        const values = [];
                        let current = '';
                        let inQuote = false;
                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            if (char === '"') {
                                inQuote = !inQuote;
                            } else if (char === ',' && !inQuote) {
                                values.push(current.trim());
                                current = '';
                            } else {
                                current += char;
                            }
                        }
                        values.push(current.trim());

                        // additional cleanup for quotes: remove surrounding quotes if present
                        return values.map(val => {
                            if (val.startsWith('"') && val.endsWith('"')) {
                                val = val.slice(1, -1);
                                // handle escaped quotes ("") -> (")
                                val = val.replace(/""/g, '"');
                            }
                            return val;
                        });
                    };

                    const headers = splitLine(lines.shift());

                    return lines.map(line => {
                        const values = splitLine(line);
                        const obj = {};
                        headers.forEach((header, i) => {
                            obj[header] = values[i] !== undefined ? values[i] : '';
                        });
                        return obj;
                    });
                } catch (e) {
                    document.getElementById('debug').textContent = 'Error in parseCSV: ' + e.message;
                    return [];
                }
            }

            // Function to transform the original data
            function transformData(originalData) {
                const transformed = [];
                const difficultyTypes = ['BEGINNER', 'NORMAL', 'HYPER', 'ANOTHER', 'LEGGENDARIA'];

                originalData.forEach(row => {
                    difficultyTypes.forEach(type => {
                        const difficulty = row[`${type} 難易度`];
                        if (difficulty === '12') {
                            transformed.push({
                                'Version': row['バージョン'],
                                'Title': row['タイトル'],
                                'Score Type': type,
                                'Score': row[`${type} スコア`],
                                'PGreat': row[`${type} PGreat`],
                                'Great': row[`${type} Great`],
                                'Miss Count': row[`${type} ミスカウント`],
                                'Clear Type': row[`${type} クリアタイプ`],
                                'DJ Level': row[`${type} DJ LEVEL`]
                            });
                        }
                    });
                });
                return transformed;
            }

            // Calculate Stats
            function calculateStats(data) {
                const stats = {
                    'FULLCOMBO CLEAR': 0,
                    'EX HARD CLEAR': 0,
                    'HARD CLEAR': 0,
                    'CLEAR': 0,
                    'EASY CLEAR': 0,
                    'ASSIST CLEAR': 0,
                    'FAILED': 0,
                    'NO PLAY': 0
                };

                // Track total to ensure we capture unexpected types too if needed, 
                // but for now let's stick to known types or initialize dynamically?
                // Standard IIDX clear types are fixed.

                data.forEach(row => {
                    const type = row['Clear Type'] ? row['Clear Type'].toUpperCase() : 'NO PLAY';
                    if (stats.hasOwnProperty(type)) {
                        stats[type]++;
                    } else {
                        // Handle unexpected types or just ignore
                        if (!stats['Other']) stats['Other'] = 0;
                        stats['Other']++;
                    }
                });
                return stats;
            }

            function renderStats(stats) {
                const container = document.getElementById('stats-container');
                let html = '';

                // Define order
                const order = ['FULLCOMBO CLEAR', 'EX HARD CLEAR', 'HARD CLEAR', 'CLEAR', 'EASY CLEAR', 'ASSIST CLEAR', 'FAILED', 'NO PLAY', 'Other'];

                order.forEach(type => {
                    if (stats[type] > 0) {
                        // Get color class for label styling match if desired, or keep generic
                        const cleanType = type.replace(/ /g, '_');
                        html += `
                            <div class="stat-item">
                                <span class="stat-label clear-type-${cleanType}">${type}</span>
                                <span class="stat-count">${stats[type]}</span>
                            </div>
                         `;
                    }
                });

                // Total count
                // const total = Object.values(stats).reduce((a, b) => a + b, 0);
                // html += `<div class="stat-item"><span class="stat-label">Total</span><span class="stat-count">${total}</span></div>`;

                container.innerHTML = html;
            }

            // Helper to escape HTML to prevent XSS
            function escapeHTML(str) {
                if (typeof str !== 'string') return str;
                return str
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            // Function to render the table
            function renderTable(data, sortHeader, sortOrder) {
                let table = '<table>';
                // headers
                table += '<thead><tr>';
                newHeaders.forEach(header => {
                    let sortClass = '';
                    if (header === sortHeader) {
                        sortClass = sortOrder === '1' ? 'sort-asc' : 'sort-desc';
                    }
                    table += `<th class="${sortClass}" data-sort="${header}">${header}</th>`;
                });
                table += '</tr></thead>';

                // body
                table += '<tbody>';
                data.forEach(row => {
                    table += '<tr>';
                    newHeaders.forEach(header => {
                        let cellContent = row[header] || '';
                        let cellClass = '';
                        if (header === 'Clear Type') {
                            cellClass = 'clear-type-' + cellContent.replace(/ /g, '_');
                        }
                        // Sanitize content before rendering
                        table += `<td class="${cellClass}">${escapeHTML(cellContent)}</td>`;
                    });
                    table += '</tr>';
                });
                table += '</tbody>';

                table += '</table>';
                document.getElementById('csv-table').innerHTML = table;

                // Re-attach sorting event listeners
                attachSortingEventListeners();
            }

            // Function to attach sorting event listeners
            function attachSortingEventListeners() {
                document.querySelectorAll('th').forEach(th => {
                    th.addEventListener('click', () => {
                        const header = th.dataset.sort;

                        if (currentSort.header === header) {
                            currentSort.order = currentSort.order === '1' ? '-1' : '1';
                        } else {
                            currentSort.header = header;
                            currentSort.order = '1';
                        }

                        const numericHeaders = ['Score', 'PGreat', 'Great', 'Miss Count'];
                        const clearTypeRank = {
                            'FULLCOMBO CLEAR': 7,
                            'EX HARD CLEAR': 6,
                            'HARD CLEAR': 5,
                            'CLEAR': 4,
                            'EASY CLEAR': 3,
                            'FAILED': 2,
                            'NO PLAY': 1
                        };
                        const djLevelRank = {
                            'AAA': 8,
                            'AA': 7,
                            'A': 6,
                            'B': 5,
                            'C': 4,
                            'D': 3,
                            'E': 2,
                            'F': 1
                        };

                        transformedData.sort((a, b) => {
                            let valA = a[header];
                            let valB = b[header];

                            if (header === 'Clear Type') {
                                valA = clearTypeRank[valA.toUpperCase()] || 0;
                                valB = clearTypeRank[valB.toUpperCase()] || 0;
                            } else if (header === 'DJ Level') {
                                valA = djLevelRank[valA.toUpperCase()] || 0;
                                valB = djLevelRank[valB.toUpperCase()] || 0;
                            } else if (numericHeaders.includes(header)) {
                                valA = (valA === '---' || valA === '') ? -Infinity : parseInt(valA, 10);
                                valB = (valB === '---' || valB === '') ? -Infinity : parseInt(valB, 10);
                            }

                            if (valA < valB) return -1 * parseInt(currentSort.order);
                            if (valA > valB) return 1 * parseInt(currentSort.order);
                            return 0;
                        });
                        applyFiltersAndRender();
                    });
                });
            }

            // Function to apply text filter and render
            function applyFiltersAndRender() {
                let filteredData = [...transformedData];
                const filterInput = document.getElementById('filter');
                const filterValue = filterInput.value.toLowerCase();

                if (filterValue) {
                    filteredData = filteredData.filter(row => {
                        return row['Title'] && row['Title'].toLowerCase().includes(filterValue);
                    });
                }

                // Calculate and render stats based on FILTERED data
                const stats = calculateStats(filteredData);
                renderStats(stats);

                renderTable(filteredData, currentSort.header, currentSort.order);
            }

            // Load data from Local Storage
            const storedData = localStorage.getItem('iidx_score_csv');

            if (storedData) {
                try {
                    let csvText = storedData;
                    if (csvText.charCodeAt(0) === 0xFEFF) {
                        csvText = csvText.substring(1);
                    }

                    const originalData = parseCSV(csvText);
                    transformedData = transformData(originalData);

                    if (transformedData.length === 0) {
                        document.getElementById('csv-table').innerHTML = '<p>No Level 12 data found in the uploaded CSV. <a href="upload.html">Upload a different file?</a></p>';
                        document.getElementById('stats-container').innerHTML = ''; // Clear stats if no data
                    } else {
                        applyFiltersAndRender();
                    }

                } catch (e) {
                    document.getElementById('debug').textContent = 'An error occurred during data processing: ' + e.message + '\n' + e.stack;
                    document.getElementById('debug').style.display = 'block';
                }
            } else { // No data found logic - updated to clear stats
                document.getElementById('csv-table').innerHTML = '<p>No data found. Please <a href="upload.html">upload your score CSV file</a>.</p>';
                document.getElementById('stats-container').innerHTML = '';
            }

            // Event listener for the filter input
            const filterInput = document.getElementById('filter');
            filterInput.addEventListener('keyup', applyFiltersAndRender);

        });
    </script>
</body>

</html>