<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IIDX DP Score Viewer</title>
    <style>
        body {
            font-family: sans-serif;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
        }

        th {
            background-color: #f2f2f2;
            text-align: left;
            cursor: pointer;
            position: relative;
        }

        th.sort-asc::after {
            content: ' ▲';
        }

        th.sort-desc::after {
            content: ' ▼';
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #filter {
            margin-bottom: 1em;
            padding: 0.5em;
            width: 100%;
            box-sizing: border-box;
        }

        .clear-type-NO_PLAY {
            color: black;
        }

        .clear-type-EASY_CLEAR {
            color: green;
        }

        .clear-type-CLEAR {
            color: blue;
        }

        .clear-type-HARD_CLEAR {
            color: red;
        }

        .clear-type-EX_HARD_CLEAR {
            color: lightyellow;
        }

        .clear-type-FULLCOMBO_CLEAR {
            color: violet;
        }
    </style>
</head>

<body>

    <h1>IIDX DP Score Viewer</h1>
    <input type="text" id="filter" placeholder="Filter by title...">
    <div id="csv-table"></div>
    <pre id="debug" style="display: none;"></pre>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            let transformedData = [];
            const newHeaders = ['Version', 'Title', 'Score Type', 'Score', 'PGreat', 'Great', 'Miss Count', 'Clear Type', 'DJ Level'];
            let currentSort = { header: null, order: '1' };

            // Function to parse CSV text
            function parseCSV(text) {
                try {
                    const lines = text.trim().split(/\r?\n/);
                    if (lines.length === 0) return [];
                    const headers = lines.shift().split(',').map(h => h.trim());
                    return lines.map(line => {
                        const values = line.split(',');
                        const obj = {};
                        headers.forEach((header, i) => {
                            obj[header] = values[i] ? values[i].trim() : '';
                        });
                        return obj;
                    });
                } catch (e) {
                    document.getElementById('debug').textContent = 'Error in parseCSV: ' + e.message;
                    return [];
                }
            }

            // Function to transform the original data
            function transformData(originalData) {
                const transformed = [];
                const difficultyTypes = ['BEGINNER', 'NORMAL', 'HYPER', 'ANOTHER', 'LEGGENDARIA'];

                originalData.forEach(row => {
                    difficultyTypes.forEach(type => {
                        const difficulty = row[`${type} 難易度`];
                        if (difficulty === '12') {
                            transformed.push({
                                'Version': row['バージョン'],
                                'Title': row['タイトル'],
                                'Score Type': type,
                                'Score': row[`${type} スコア`],
                                'PGreat': row[`${type} PGreat`],
                                'Great': row[`${type} Great`],
                                'Miss Count': row[`${type} ミスカウント`],
                                'Clear Type': row[`${type} クリアタイプ`],
                                'DJ Level': row[`${type} DJ LEVEL`]
                            });
                        }
                    });
                });
                return transformed;
            }

            // Function to render the table
            function renderTable(data, sortHeader, sortOrder) {
                let table = '<table>';
                // headers
                table += '<thead><tr>';
                newHeaders.forEach(header => {
                    let sortClass = '';
                    if (header === sortHeader) {
                        sortClass = sortOrder === '1' ? 'sort-asc' : 'sort-desc';
                    }
                    table += `<th class="${sortClass}" data-sort="${header}">${header}</th>`;
                });
                table += '</tr></thead>';

                // body
                table += '<tbody>';
                data.forEach(row => {
                    table += '<tr>';
                    newHeaders.forEach(header => {
                        let cellContent = row[header] || '';
                        let cellClass = '';
                        if (header === 'Clear Type') {
                            cellClass = 'clear-type-' + cellContent.replace(/ /g, '_');
                        }
                        table += `<td class="${cellClass}">${cellContent}</td>`;
                    });
                    table += '</tr>';
                });
                table += '</tbody>';

                table += '</table>';
                document.getElementById('csv-table').innerHTML = table;

                // Re-attach sorting event listeners
                attachSortingEventListeners();
            }

            // Function to attach sorting event listeners
            function attachSortingEventListeners() {
                document.querySelectorAll('th').forEach(th => {
                    th.addEventListener('click', () => {
                        const header = th.dataset.sort;

                        if (currentSort.header === header) {
                            currentSort.order = currentSort.order === '1' ? '-1' : '1';
                        } else {
                            currentSort.header = header;
                            currentSort.order = '1';
                        }

                        const numericHeaders = ['Score', 'PGreat', 'Great', 'Miss Count'];
                        const clearTypeRank = {
                            'FULLCOMBO CLEAR': 7,
                            'EX HARD CLEAR': 6,
                            'HARD CLEAR': 5,
                            'CLEAR': 4,
                            'EASY CLEAR': 3,
                            'FAILED': 2,
                            'NO PLAY': 1
                        };
                        const djLevelRank = {
                            'AAA': 8,
                            'AA': 7,
                            'A': 6,
                            'B': 5,
                            'C': 4,
                            'D': 3,
                            'E': 2,
                            'F': 1
                        };

                        transformedData.sort((a, b) => {
                            let valA = a[header];
                            let valB = b[header];

                            if (header === 'Clear Type') {
                                valA = clearTypeRank[valA.toUpperCase()] || 0;
                                valB = clearTypeRank[valB.toUpperCase()] || 0;
                            } else if (header === 'DJ Level') {
                                valA = djLevelRank[valA.toUpperCase()] || 0;
                                valB = djLevelRank[valB.toUpperCase()] || 0;
                            } else if (numericHeaders.includes(header)) {
                                valA = (valA === '---' || valA === '') ? -Infinity : parseInt(valA, 10);
                                valB = (valB === '---' || valB === '') ? -Infinity : parseInt(valB, 10);
                            }

                            if (valA < valB) return -1 * parseInt(currentSort.order);
                            if (valA > valB) return 1 * parseInt(currentSort.order);
                            return 0;
                        });
                        applyFiltersAndRender();
                    });
                });
            }

            // Function to apply text filter and render
            function applyFiltersAndRender() {
                let filteredData = [...transformedData];
                const filterInput = document.getElementById('filter');
                const filterValue = filterInput.value.toLowerCase();

                if (filterValue) {
                    filteredData = filteredData.filter(row => {
                        return row['Title'] && row['Title'].toLowerCase().includes(filterValue);
                    });
                }

                renderTable(filteredData, currentSort.header, currentSort.order);
            }

            // Fetch and process the CSV data
            fetch('5771-1854_dp_score.csv')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(csvText => {
                    try {
                        if (csvText.charCodeAt(0) === 0xFEFF) {
                            csvText = csvText.substring(1);
                        }

                        const originalData = parseCSV(csvText);
                        transformedData = transformData(originalData);

                        applyFiltersAndRender();

                    } catch (e) {
                        document.getElementById('debug').textContent = 'An error occurred during data processing: ' + e.message + '\n' + e.stack;
                        document.getElementById('debug').style.display = 'block';
                    }
                })
                .catch(e => {
                    document.getElementById('debug').textContent = 'An error occurred fetching the CSV file: ' + e.message;
                    document.getElementById('debug').style.display = 'block';
                });

            // Event listener for the filter input
            const filterInput = document.getElementById('filter');
            filterInput.addEventListener('keyup', applyFiltersAndRender);

        });
    </script>
</body>

</html>